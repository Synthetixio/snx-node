{"version":3,"file":"448.index.js","mappings":"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","sources":["webpack://synthetix-node/./node_modules/viem/_esm/errors/ccip.js","webpack://synthetix-node/./node_modules/viem/_esm/utils/ccip.js","webpack://synthetix-node/./node_modules/viem/_esm/utils/address/isAddressEqual.js"],"sourcesContent":["import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nimport { getUrl } from './utils.js';\nexport class OffchainLookupError extends BaseError {\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls\n  }) {\n    super(cause.shortMessage || 'An error occurred while fetching for an offchain result.', {\n      cause,\n      metaMessages: [...(cause.metaMessages || []), cause.metaMessages?.length ? '' : [], 'Offchain Gateway Call:', urls && ['  Gateway URL(s):', ...urls.map(url => `    ${getUrl(url)}`)], `  Sender: ${sender}`, `  Data: ${data}`, `  Callback selector: ${callbackSelector}`, `  Extra data: ${extraData}`].flat()\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'OffchainLookupError'\n    });\n  }\n}\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  constructor({\n    result,\n    url\n  }) {\n    super('Offchain gateway response is malformed. Response data must be a hex value.', {\n      metaMessages: [`Gateway URL: ${getUrl(url)}`, `Response: ${stringify(result)}`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'OffchainLookupResponseMalformedError'\n    });\n  }\n}\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  constructor({\n    sender,\n    to\n  }) {\n    super('Reverted sender address does not match target contract address (`to`).', {\n      metaMessages: [`Contract address: ${to}`, `OffchainLookup sender address: ${sender}`]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'OffchainLookupSenderMismatchError'\n    });\n  }\n}","import { call } from '../actions/public/call.js';\nimport '../errors/base.js';\nimport { OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError } from '../errors/ccip.js';\nimport { HttpRequestError } from '../errors/request.js';\nimport { decodeErrorResult } from './abi/decodeErrorResult.js';\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js';\nimport { isAddressEqual } from './address/isAddressEqual.js';\nimport { concat } from './data/concat.js';\nimport { isHex } from './data/isHex.js';\nimport { stringify } from './stringify.js';\nexport const offchainLookupSignature = '0x556f1830';\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [{\n    name: 'sender',\n    type: 'address'\n  }, {\n    name: 'urls',\n    type: 'string[]'\n  }, {\n    name: 'callData',\n    type: 'bytes'\n  }, {\n    name: 'callbackFunction',\n    type: 'bytes4'\n  }, {\n    name: 'extraData',\n    type: 'bytes'\n  }]\n};\nexport async function offchainLookup(client, {\n  blockNumber,\n  blockTag,\n  data,\n  to\n}) {\n  const {\n    args\n  } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem]\n  });\n  const [sender, urls, callData, callbackSelector, extraData] = args;\n  try {\n    if (!isAddressEqual(to, sender)) throw new OffchainLookupSenderMismatchError({\n      sender,\n      to\n    });\n    const result = await ccipFetch({\n      data: callData,\n      sender,\n      urls\n    });\n    const {\n      data: data_\n    } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([callbackSelector, encodeAbiParameters([{\n        type: 'bytes'\n      }, {\n        type: 'bytes'\n      }], [result, extraData])]),\n      to\n    });\n    return data_;\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err,\n      data,\n      extraData,\n      sender,\n      urls\n    });\n  }\n}\nexport async function ccipFetch({\n  data,\n  sender,\n  urls\n}) {\n  let error = new Error('An unknown error occurred.');\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i];\n    const method = url.includes('{data}') ? 'GET' : 'POST';\n    const body = method === 'POST' ? {\n      data,\n      sender\n    } : undefined;\n    try {\n      const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {\n        body: JSON.stringify(body),\n        method\n      });\n      let result;\n      if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n        result = (await response.json()).data;\n      } else {\n        result = await response.text();\n      }\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: result?.error ? stringify(result.error) : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url\n        });\n        continue;\n      }\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url\n        });\n        continue;\n      }\n      return result;\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: err.message,\n        url\n      });\n    }\n  }\n  throw error;\n}","import { InvalidAddressError } from '../../errors/address.js';\nimport { isAddress } from './isAddress.js';\nexport function isAddressEqual(a, b) {\n  if (!isAddress(a, {\n    strict: false\n  })) throw new InvalidAddressError({\n    address: a\n  });\n  if (!isAddress(b, {\n    strict: false\n  })) throw new InvalidAddressError({\n    address: b\n  });\n  return a.toLowerCase() === b.toLowerCase();\n}"],"names":["OffchainLookupError","constructor","callbackSelector","cause","data","extraData","sender","urls","super","shortMessage","metaMessages","length","map","url","flat","Object","defineProperty","this","enumerable","configurable","writable","value","OffchainLookupResponseMalformedError","result","stringify","OffchainLookupSenderMismatchError","to","offchainLookupSignature","offchainLookupAbiItem","name","type","inputs","async","offchainLookup","client","blockNumber","blockTag","args","decodeErrorResult","abi","callData","a","b","isAddress","strict","address","toLowerCase","isAddressEqual","error","Error","i","method","includes","body","undefined","response","fetch","replace","JSON","headers","get","startsWith","json","text","ok","details","statusText","status","isHex","err","message","ccipFetch","data_","call","concat","encodeAbiParameters"],"sourceRoot":""}