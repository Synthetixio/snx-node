{"version":3,"file":"848.index.js","mappings":"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","sources":["webpack://synthetix-node/./node_modules/node-fetch/src/utils/multipart-parser.js"],"sourcesContent":["import { File } from 'fetch-blob/from.js';\nimport { FormData } from 'formdata-polyfill/esm.min.js';\nlet s = 0;\nconst S = {\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  END: s++\n};\nlet f = 1;\nconst F = {\n  PART_BOUNDARY: f,\n  LAST_BOUNDARY: f *= 2\n};\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\nconst lower = c => c | 0x20;\nconst noop = () => {};\nclass MultipartParser {\n  /**\n   * @param {string} boundary\n   */\n  constructor(boundary) {\n    this.index = 0;\n    this.flags = 0;\n    this.onHeaderEnd = noop;\n    this.onHeaderField = noop;\n    this.onHeadersEnd = noop;\n    this.onHeaderValue = noop;\n    this.onPartBegin = noop;\n    this.onPartData = noop;\n    this.onPartEnd = noop;\n    this.boundaryChars = {};\n    boundary = '\\r\\n--' + boundary;\n    const ui8a = new Uint8Array(boundary.length);\n    for (let i = 0; i < boundary.length; i++) {\n      ui8a[i] = boundary.charCodeAt(i);\n      this.boundaryChars[ui8a[i]] = true;\n    }\n    this.boundary = ui8a;\n    this.lookbehind = new Uint8Array(this.boundary.length + 8);\n    this.state = S.START_BOUNDARY;\n  }\n\n  /**\n   * @param {Uint8Array} data\n   */\n  write(data) {\n    let i = 0;\n    const length_ = data.length;\n    let previousIndex = this.index;\n    let {\n      lookbehind,\n      boundary,\n      boundaryChars,\n      index,\n      state,\n      flags\n    } = this;\n    const boundaryLength = this.boundary.length;\n    const boundaryEnd = boundaryLength - 1;\n    const bufferLength = data.length;\n    let c;\n    let cl;\n    const mark = name => {\n      this[name + 'Mark'] = i;\n    };\n    const clear = name => {\n      delete this[name + 'Mark'];\n    };\n    const callback = (callbackSymbol, start, end, ui8a) => {\n      if (start === undefined || start !== end) {\n        this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n      }\n    };\n    const dataCallback = (name, clear) => {\n      const markSymbol = name + 'Mark';\n      if (!(markSymbol in this)) {\n        return;\n      }\n      if (clear) {\n        callback(name, this[markSymbol], i, data);\n        delete this[markSymbol];\n      } else {\n        callback(name, this[markSymbol], data.length, data);\n        this[markSymbol] = 0;\n      }\n    };\n    for (i = 0; i < length_; i++) {\n      c = data[i];\n      switch (state) {\n        case S.START_BOUNDARY:\n          if (index === boundary.length - 2) {\n            if (c === HYPHEN) {\n              flags |= F.LAST_BOUNDARY;\n            } else if (c !== CR) {\n              return;\n            }\n            index++;\n            break;\n          } else if (index - 1 === boundary.length - 2) {\n            if (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n              state = S.END;\n              flags = 0;\n            } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n              index = 0;\n              callback('onPartBegin');\n              state = S.HEADER_FIELD_START;\n            } else {\n              return;\n            }\n            break;\n          }\n          if (c !== boundary[index + 2]) {\n            index = -2;\n          }\n          if (c === boundary[index + 2]) {\n            index++;\n          }\n          break;\n        case S.HEADER_FIELD_START:\n          state = S.HEADER_FIELD;\n          mark('onHeaderField');\n          index = 0;\n        // falls through\n        case S.HEADER_FIELD:\n          if (c === CR) {\n            clear('onHeaderField');\n            state = S.HEADERS_ALMOST_DONE;\n            break;\n          }\n          index++;\n          if (c === HYPHEN) {\n            break;\n          }\n          if (c === COLON) {\n            if (index === 1) {\n              // empty header field\n              return;\n            }\n            dataCallback('onHeaderField', true);\n            state = S.HEADER_VALUE_START;\n            break;\n          }\n          cl = lower(c);\n          if (cl < A || cl > Z) {\n            return;\n          }\n          break;\n        case S.HEADER_VALUE_START:\n          if (c === SPACE) {\n            break;\n          }\n          mark('onHeaderValue');\n          state = S.HEADER_VALUE;\n        // falls through\n        case S.HEADER_VALUE:\n          if (c === CR) {\n            dataCallback('onHeaderValue', true);\n            callback('onHeaderEnd');\n            state = S.HEADER_VALUE_ALMOST_DONE;\n          }\n          break;\n        case S.HEADER_VALUE_ALMOST_DONE:\n          if (c !== LF) {\n            return;\n          }\n          state = S.HEADER_FIELD_START;\n          break;\n        case S.HEADERS_ALMOST_DONE:\n          if (c !== LF) {\n            return;\n          }\n          callback('onHeadersEnd');\n          state = S.PART_DATA_START;\n          break;\n        case S.PART_DATA_START:\n          state = S.PART_DATA;\n          mark('onPartData');\n        // falls through\n        case S.PART_DATA:\n          previousIndex = index;\n          if (index === 0) {\n            // boyer-moore derrived algorithm to safely skip non-boundary data\n            i += boundaryEnd;\n            while (i < bufferLength && !(data[i] in boundaryChars)) {\n              i += boundaryLength;\n            }\n            i -= boundaryEnd;\n            c = data[i];\n          }\n          if (index < boundary.length) {\n            if (boundary[index] === c) {\n              if (index === 0) {\n                dataCallback('onPartData', true);\n              }\n              index++;\n            } else {\n              index = 0;\n            }\n          } else if (index === boundary.length) {\n            index++;\n            if (c === CR) {\n              // CR = part boundary\n              flags |= F.PART_BOUNDARY;\n            } else if (c === HYPHEN) {\n              // HYPHEN = end boundary\n              flags |= F.LAST_BOUNDARY;\n            } else {\n              index = 0;\n            }\n          } else if (index - 1 === boundary.length) {\n            if (flags & F.PART_BOUNDARY) {\n              index = 0;\n              if (c === LF) {\n                // unset the PART_BOUNDARY flag\n                flags &= ~F.PART_BOUNDARY;\n                callback('onPartEnd');\n                callback('onPartBegin');\n                state = S.HEADER_FIELD_START;\n                break;\n              }\n            } else if (flags & F.LAST_BOUNDARY) {\n              if (c === HYPHEN) {\n                callback('onPartEnd');\n                state = S.END;\n                flags = 0;\n              } else {\n                index = 0;\n              }\n            } else {\n              index = 0;\n            }\n          }\n          if (index > 0) {\n            // when matching a possible boundary, keep a lookbehind reference\n            // in case it turns out to be a false lead\n            lookbehind[index - 1] = c;\n          } else if (previousIndex > 0) {\n            // if our boundary turned out to be rubbish, the captured lookbehind\n            // belongs to partData\n            const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n            callback('onPartData', 0, previousIndex, _lookbehind);\n            previousIndex = 0;\n            mark('onPartData');\n\n            // reconsider the current character even so it interrupted the sequence\n            // it could be the beginning of a new sequence\n            i--;\n          }\n          break;\n        case S.END:\n          break;\n        default:\n          throw new Error(`Unexpected state entered: ${state}`);\n      }\n    }\n    dataCallback('onHeaderField');\n    dataCallback('onHeaderValue');\n    dataCallback('onPartData');\n\n    // Update properties for the next call\n    this.index = index;\n    this.state = state;\n    this.flags = flags;\n  }\n  end() {\n    if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {\n      this.onPartEnd();\n    } else if (this.state !== S.END) {\n      throw new Error('MultipartParser.end(): stream ended unexpectedly');\n    }\n  }\n}\nfunction _fileName(headerValue) {\n  // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n  const m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n  if (!m) {\n    return;\n  }\n  const match = m[2] || m[3] || '';\n  let filename = match.slice(match.lastIndexOf('\\\\') + 1);\n  filename = filename.replace(/%22/g, '\"');\n  filename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n    return String.fromCharCode(code);\n  });\n  return filename;\n}\nexport async function toFormData(Body, ct) {\n  if (!/multipart/i.test(ct)) {\n    throw new TypeError('Failed to fetch');\n  }\n  const m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n  if (!m) {\n    throw new TypeError('no or bad content-type header, no multipart boundary');\n  }\n  const parser = new MultipartParser(m[1] || m[2]);\n  let headerField;\n  let headerValue;\n  let entryValue;\n  let entryName;\n  let contentType;\n  let filename;\n  const entryChunks = [];\n  const formData = new FormData();\n  const onPartData = ui8a => {\n    entryValue += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n  const appendToFile = ui8a => {\n    entryChunks.push(ui8a);\n  };\n  const appendFileToFormData = () => {\n    const file = new File(entryChunks, filename, {\n      type: contentType\n    });\n    formData.append(entryName, file);\n  };\n  const appendEntryToFormData = () => {\n    formData.append(entryName, entryValue);\n  };\n  const decoder = new TextDecoder('utf-8');\n  decoder.decode();\n  parser.onPartBegin = function () {\n    parser.onPartData = onPartData;\n    parser.onPartEnd = appendEntryToFormData;\n    headerField = '';\n    headerValue = '';\n    entryValue = '';\n    entryName = '';\n    contentType = '';\n    filename = null;\n    entryChunks.length = 0;\n  };\n  parser.onHeaderField = function (ui8a) {\n    headerField += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n  parser.onHeaderValue = function (ui8a) {\n    headerValue += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n  parser.onHeaderEnd = function () {\n    headerValue += decoder.decode();\n    headerField = headerField.toLowerCase();\n    if (headerField === 'content-disposition') {\n      // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n      const m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n      if (m) {\n        entryName = m[2] || m[3] || '';\n      }\n      filename = _fileName(headerValue);\n      if (filename) {\n        parser.onPartData = appendToFile;\n        parser.onPartEnd = appendFileToFormData;\n      }\n    } else if (headerField === 'content-type') {\n      contentType = headerValue;\n    }\n    headerValue = '';\n    headerField = '';\n  };\n  for await (const chunk of Body) {\n    parser.write(chunk);\n  }\n  parser.end();\n  return formData;\n}"],"names":["s","S","START_BOUNDARY","HEADER_FIELD_START","HEADER_FIELD","HEADER_VALUE_START","HEADER_VALUE","HEADER_VALUE_ALMOST_DONE","HEADERS_ALMOST_DONE","PART_DATA_START","PART_DATA","END","f","F","lower","c","noop","MultipartParser","constructor","boundary","this","index","flags","onHeaderEnd","onHeaderField","onHeadersEnd","onHeaderValue","onPartBegin","onPartData","onPartEnd","boundaryChars","ui8a","Uint8Array","length","i","charCodeAt","lookbehind","state","write","data","length_","previousIndex","boundaryLength","boundaryEnd","bufferLength","cl","mark","name","clear","callback","callbackSymbol","start","end","undefined","subarray","dataCallback","markSymbol","_lookbehind","buffer","byteOffset","byteLength","Error","async","toFormData","Body","ct","test","TypeError","m","match","parser","headerField","headerValue","entryValue","entryName","contentType","filename","entryChunks","formData","decoder","decode","stream","appendToFile","push","appendFileToFormData","file","type","append","appendEntryToFormData","TextDecoder","toLowerCase","slice","lastIndexOf","replace","code","String","fromCharCode","_fileName","chunk"],"sourceRoot":""}